#!/usr/bin/env python3
import sys
import os
import yaml
import subprocess
import argparse
import re

# ANSI color codes
GREEN = "\033[32m"
RED   = "\033[31m"
RESET = "\033[0m"

# ── Usage: python gen_dotfiles.py [--avoid-collisions] [zsh|pwsh] ────────────
p = argparse.ArgumentParser(description="Generate unified shell dotfiles for zsh/pwsh")
p.add_argument("shell", choices=("zsh","pwsh"), help="Target shell")
p.add_argument(
    "--avoid-collisions",
    action="store_true",
    dest="avoid",
    help="Switch aliases to functions when colliding with built‑in shell aliases"
)
args = p.parse_args()
shell = args.shell
avoid = args.avoid

project_root = os.path.dirname(os.path.abspath(__file__))
defs_dir     = os.path.join(project_root, "definitions")
aliases_dir  = os.path.join(defs_dir, "aliases")
funcs_dir    = os.path.join(defs_dir, "functions")
out_dir      = os.path.join(project_root, "out", shell)
os.makedirs(out_dir, exist_ok=True)

# choose extension
ext = "ps1" if shell == "pwsh" else "zsh"
output_path = os.path.join(out_dir, f"unified.{ext}")

# ── helper to write lines ────────────────────────────────────────────────────
lines = []
def w(l=""):
    lines.append(l)

# ── detect built‑in aliases (for collision avoidance) ─────────────────────────
target_builtins = set()
if avoid:
    if shell == "pwsh":
        try:
            out = subprocess.check_output(
                ["pwsh", "-NoProfile", "-Command", "Get-Alias | Select-Object -ExpandProperty Name"],
                text=True
            )
            target_builtins = set(out.split())
        except:
            print(f"{RED}Warning:{RESET} could not load built‑in pwsh aliases", file=sys.stderr)
    else:
        try:
            out = subprocess.check_output(["zsh","-i","-c","alias"], text=True)
            for l in out.splitlines():
                m = re.match(r"^([A-Za-z0-9_+-]+)=", l)
                if m: target_builtins.add(m.group(1))
        except:
            print(f"{RED}Warning:{RESET} could not load built‑in zsh aliases", file=sys.stderr)

# ── load aliases/*.yml ───────────────────────────────────────────────────────
aliases = []
print("🔍 Scanning alias definitions:")
for fname in sorted(os.listdir(aliases_dir)):
    if not fname.lower().endswith((".yml","yaml")):
        continue
    full = os.path.join(aliases_dir, fname)
    try:
        data = yaml.safe_load(open(full, encoding="utf-8"))
        if not isinstance(data, dict) or "aliases" not in data:
            raise KeyError("no top‑level 'aliases' key")
        aliases.extend(data["aliases"])
        print(f"  {GREEN}✅ {fname}{RESET}")
    except Exception as e:
        print(f"  {RED}❌ {fname}:{RESET} {e}")

# Normalize so every alias has a "command" key
for a in aliases:
    if "command" not in a:
        for alt in ("cmd","body","value"):
            if alt in a:
                a["command"] = a[alt]
                break

# ── load functions/*.yml ─────────────────────────────────────────────────────
functions = []
print("🔍 Scanning function definitions:")
for fname in sorted(os.listdir(funcs_dir)):
    if not fname.lower().endswith((".yml","yaml")):
        continue
    full = os.path.join(funcs_dir, fname)
    try:
        data = yaml.safe_load(open(full, encoding="utf-8"))
        if not isinstance(data, dict) or "functions" not in data:
            raise KeyError("no top‑level 'functions' key")
        functions.extend(data["functions"])
        print(f"  {GREEN}✅ {fname}{RESET}")
    except Exception as e:
        print(f"  {RED}❌ {fname}:{RESET} {e}")

# ── header & dispatcher for pwsh ─────────────────────────────────────────────
if shell == "pwsh":
    helper = os.path.join(out_dir, "dotcmd_helper.ps1")
    if os.path.exists(helper):
        w("# dotcmd dispatcher")
        w("".join(open(helper, encoding="utf-8").read().splitlines(True)))
        w()
    else:
        w("# WARNING: dotcmd_helper.ps1 missing; dotcmd calls will fail")
        w()

w(f"# autogenerated — unified {shell} config")
w()

# ── emit functions first ─────────────────────────────────────────────────────
for fn in functions:
    helpstr = fn.get("help","").strip()
    if helpstr:
        w(f"# {helpstr}")
    body = fn["body"]
    if isinstance(body, dict):
        snippet = body.get(shell,"").rstrip()
        if snippet:
            lines += snippet.splitlines()
            w()
    else:
        lines += str(body).splitlines()
        w()

# ── emit aliases with per‑shell and collision logic ───────────────────────────
for a in aliases:
    name    = a.get("name")
    raw_cmd = a.get("command","")
    helpstr = a.get("help","").strip()

    # pick per‑shell if a dict
    if isinstance(raw_cmd, dict):
        cmd = raw_cmd.get(shell,"").strip()
        if not cmd:
            print(f"{RED}❌ Skipping alias '{name}': no '{shell}' entry{RESET}")
            continue
    else:
        cmd = str(raw_cmd).strip()

    if helpstr:
        w(f"# {helpstr}")

    collide = avoid and (name in target_builtins)
    if collide:
        print(f"{RED}⚠ Switched '{name}' to function (built‑in collision){RESET}")
        if shell == "zsh":
            w(f"function {name}() {{ {cmd} \"$@\"; }}")
        else:
            w(f"function {name} {{")
            w("  param([Parameter(ValueFromRemainingArguments=$true)] $args)")
            w(f"  {cmd} $args")
            w("}")
    else:
        if shell == "zsh":
            w(f"alias {name}='{cmd}'")
        else:
            # flatten spots: Set-Alias only takes one token after -Value
            alias_cmd = " ".join(cmd.split())
            w(f"Set-Alias -Name {name} -Value {alias_cmd}")
    w()

# ── write the final file ─────────────────────────────────────────────────────
with open(output_path, "w", encoding="utf-8") as f:
    f.write("\n".join(lines) + "\n")

print(f"\n🎉 Generated {output_path}")
